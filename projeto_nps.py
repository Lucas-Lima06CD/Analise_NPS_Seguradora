# -*- coding: utf-8 -*-
"""Projeto NPS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fefljRLW7cjcYFz8lOtX138r3LM2nsPM

Import de Bibliotecas Utilizadas no Projeto
"""

import numpy as np
import pandas as pd
import seaborn as sns
import statsmodels.api as sm
from statsmodels.stats.outliers_influence import variance_inflation_factor
import matplotlib.pyplot as plt

"""Carregando base de dados"""

from google.colab import files
uploaded = files.upload()

import pandas as pd
df = pd.read_csv("nps_simulado.csv")
df.head()

df

"""# **Estatistica Descritiva**"""

# Análise Completa dos dados
print("===== Estatísticas Gerais === ==")
print(df.describe(include="all").transpose())

# Análise extra dos dados
stats_extra = pd.DataFrame({
    'missing (%)': df.isnull().mean() * 100,
    'unique_values': df.nunique(),
    'most_frequent': df.mode().iloc[0],
    'variance': df.var(numeric_only=True),
    'coef_var (%)': (df.std(numeric_only=True) / df.mean(numeric_only=True)) * 100
})

print("\n===== Estatísticas Adicionais =====")
print(stats_extra)

# Distribuição dos Dados com Curva de Densidade
numericas = df.select_dtypes(include=['int64', 'float64']).columns
sns.set(style="whitegrid")

for col in numericas:
    plt.figure(figsize=(6, 3))
    sns.histplot(df[col], kde=True, bins=30)
    plt.title(f"Distribuição de {col} com Curva de Densidade (KDE)", fontsize=14)
    plt.xlabel(col)
    plt.ylabel("Frequência")
    plt.tight_layout()
    plt.show()

# Heatmap Correlação
plt.figure(figsize=(7,6))
corr = df.corr()
plt.imshow(corr, vmin=-1, vmax=1)
plt.colorbar()
plt.xticks(range(len(corr.columns)), corr.columns, rotation=45)
plt.yticks(range(len(corr.columns)), corr.columns)
plt.title("Matriz de Correlação")
plt.tight_layout()
plt.show()



"""Regressão Múltipla"""

# Modelagem
X = df[["tempo_resposta", "interacoes", "etapas", "sla", "reabertura", "valor_sinistro"]]
X = sm.add_constant(X)
y = df["nps"]

model = sm.OLS(y, X).fit(cov_type="HC3")
print(model.summary())

plt.figure(figsize=(8,5))
plt.scatter(df["tempo_resposta"], df["nps"], alpha=0.6)
coef = np.polyfit(df["tempo_resposta"], df["nps"], 1)
xs = np.linspace(df["tempo_resposta"].min(), df["tempo_resposta"].max(), 100)
ys = np.polyval(coef, xs)
plt.plot(xs, ys)
plt.xlabel("Tempo de Resposta (h)")
plt.ylabel("NPS (0 a 10)")
plt.title("Relação entre NPS e Tempo de Resposta")
plt.grid(True)
plt.show()

"""Multicolinearidade"""

X_vif = df[["tempo_resposta", "interacoes", "etapas", "sla", "reabertura", "valor_sinistro"]]

vif = pd.DataFrame()
vif["Variável"] = X_vif.columns
vif["VIF"] = [variance_inflation_factor(X_vif.values, i) for i in range(X_vif.shape[1])]
print(vif)

"""BoxPlot"""

params = model.params
conf = model.conf_int()
coef_df = pd.DataFrame({
    "coef": params,
    "ci_lower": conf[0],
    "ci_upper": conf[1]
}).drop("const")

plt.figure(figsize=(8,5))
y_pos = np.arange(len(coef_df))
plt.barh(y_pos, coef_df["coef"])
plt.errorbar(coef_df["coef"], y_pos,
             xerr=[coef_df["coef"] - coef_df["ci_lower"],
                   coef_df["ci_upper"] - coef_df["coef"]],
             fmt="none", capsize=4)
plt.yticks(y_pos, coef_df.index)
plt.axvline(0, linestyle="--")
plt.title("Coeficientes Estimados do Modelo")
plt.xlabel("Valor do Coeficiente")
plt.tight_layout()
plt.show()